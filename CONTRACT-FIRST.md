# Contract-first в tsrest-multi-repo-demo

Документ описывает, как в демо используется подход contract-first на базе **ts-rest** и **zod**, как между сервисами распространяются контракты, и как расширять систему.

## Состав репозитория
- `contracts` — единый источник контрактов (`@acme/contracts`), сборка через `tsup`.
- `auth` — сервис авторизации, выдает и валидирует токены для BFF.
- `bff` — публичный API для фронтенда, NestJS + `@ts-rest/nest`, генерирует Swagger из контракта.
- `manager` — внутренний API пользователей, NestJS + `@ts-rest/nest`, Swagger из контракта.
- `repo` — внутренний API товаров, NestJS + `@ts-rest/nest`, Swagger из контракта.
- `frontend` — Next.js UI, использует `@ts-rest/core` клиент по публичному контракту.

## Схема работы
```text
                [contracts: bffFrontendContract, bffManagerContract, bffRepoContract]
                                        |
                                build (tsup) -> dist
                                        |
                           consumed as file:../contracts package
                                        |
   Browser (Next.js)
        | initClient(bffFrontendContract)
        v
   BFF (Nest) -------------------------------------------------------------+
        | TsRestHandler(bffFrontendContract)                              |
        | initClient(authContract)    -> Auth (Nest, issue/validate token)|
        | initClient(bffManagerContract) -> Manager (Nest, in-memory users)|
        | initClient(bffRepoContract)    -> Repo (Nest, in-memory items)   |
        +------------------------------------------------------------------+
                                        |
                             Swagger/OpenAPI = generateOpenApi(contract)
```

## Контракты (источник правды)
Файлы: `contracts/src/contracts/*.ts` экспортируются из `contracts/src/index.ts`.
- `bffFrontendContract` (`/v1/...`) — публичные ручки BFF: `POST /auth/login`, `GET /users/:id`, `POST /users`, `GET /items/:id`.
- `bffManagerContract` (`/internal/v1/users...`) — внутренняя коммуникация BFF → Manager: чтение/создание пользователя.
- `bffRepoContract` (`/internal/v1/items...`) — внутренняя коммуникация BFF → Repo: чтение товара.
- `authContract` (`/internal/v1/auth/...`) — внутренняя коммуникация BFF → Auth: выдача токена и проверка валидности.

Контракты описаны zod-схемами, поэтому типы запроса/ответа и валидация данных синхронизированы между клиентом и сервером.

## Серверная реализация по контракту
- **BFF** (`bff/src/controller.ts`) подключает `@TsRestHandler(bffFrontendContract)` и реализует маппинг методов `tsRestHandler`, используя `initClient` по внутренним контрактам для проксирования в Manager/Repo.
- **Manager** (`manager/src/controller.ts`) и **Repo** (`repo/src/controller.ts`) используют те же `@TsRestHandler`/`tsRestHandler` по своим контрактам; тело хендлеров строго типизировано под зод-схемы.
- **Auth** (`auth/src/controller.ts`) использует `authContract` для выдачи токена (`POST /internal/v1/auth/login`) и проверки валидности (`POST /internal/v1/auth/validate`).
- **BFF guard** (`bff/src/auth.guard.ts`) проверяет входящие публичные ручки: извлекает токен из cookie/`Authorization` и валидирует через `authContract`; ручка логина исключена из проверки.
- **Swagger** (`*/src/main.ts`) создается через `generateOpenApi(contract, ...)`, поэтому UI всегда отражает актуальный контракт без дополнительной спецификации.

## Клиентское использование
- **Frontend** (`frontend/app/page.tsx`) создает ts-rest клиент `initClient(bffFrontendContract)` с `NEXT_PUBLIC_BFF_URL`, при инициализации вызывает `POST /v1/auth/login` (логин/пароль `test`/`test`) для получения токена в cookie и далее обращается к публичным ручкам; типы запросов/ответов автоматически выводятся из контракта.
- **BFF** использует ts-rest клиенты для внутренних вызовов (`bffManagerContract`, `bffRepoContract`), избегая ручного описания DTO.

## Пошаговый contract-first workflow для новых ручек
1) **Обновить контракт** в `contracts/src/contracts/...` (метод, путь, тело, ответы, zod-схемы). Добавить export в `contracts/src/index.ts` при необходимости.
2) **Собрать/опубликовать контракт**: `npm run build` в `contracts` (или `npm run dev` для watch). Убедиться, что зависимости на `file:../contracts` видят обновленный `dist`.
3) **Реализовать сервер**: в нужном сервисе добавить обработчик в `tsRestHandler` под новую ручку, опираясь на типы из контракта.
4) **Прокинуть через BFF** (если ручка должна быть доступна снаружи): добавить маппинг/проксирование в `bff/src/controller.ts`.
5) **Использовать на клиенте**: вызвать новый метод через `initClient` в фронтенде или другом сервисе. Типы уже доступны из пакета контрактов.
6) **Проверить Swagger/OpenAPI**: поднять сервисы и открыть `/docs` (или `/openapi.json`) — спецификация генерируется из контракта.

## Ограничения текущей реализации
- Нет версии/совместимости контрактов: потребители зависят от локального `file:../contracts`; отсутствие семантического versioning и процесса публикации.
- Нет автоматических проверок покрытия контрактов тестами (e2e/contract tests) и линтинга схем; возможен дрейф поведения от контракта на уровне бизнес-логики.
- Хранилище in-memory, без персистентности и без обработки конкурентных сценариев; демо-данные сбрасываются при рестарте.
- Нет единого формата ошибок/метаданных (только `{ message: string }`), нет деталей об аутентификации/авторизации.
- Нет наблюдаемости: логирование/метрики/трассировка отсутствуют, сложнее отлаживать интеграции.
- Frontend использует голый UI без обработки состояний ошибок/лоадеров, что ограничивает демонстрацию прод-паттернов.

## Идеи улучшений
- Ввести публикацию `@acme/contracts` в приватный registry c версионированием, changelog и зависимостями через semver вместо `file:`.
- Добавить CI pipeline: `npm run lint`/tests для контрактов, сборка, проверка, что сервисы поднимаются и Swagger успешно генерируется.
- Контрактные тесты: e2e проверки BFF ↔ Manager/Repo по контракту (например, `ts-rest` test helpers или supertest), плюс snapshot OpenAPI.
- Единый формат ошибок и обертка ответа (envelope) в контрактах для согласованности.
- Расширить контракты: пагинация, фильтрация, сортировки; добавить валидацию/документацию по auth (headers, scopes).
- Вынести общие клиентские фабрики (baseUrl, headers, middleware) в пакет или `@acme/contracts/clients` для переиспользования.
- Добавить реальное хранилище (Postgres/sqlite) и seed-скрипты, чтобы показать миграции и работу с данными.

## Roadmap (предложение)
- 0.1.x — стабилизировать контракты, добавить линт/тесты и базовый CI; договориться о формате ошибок.
- 0.2.0 — перенести пакеты на registry с semver, внедрить контрактные e2e тесты и авто-генерацию Swagger артефактов.
- 0.3.0 — внедрить БД и базовую авторизацию/аудит, расширить контракты (пагинация/фильтры) и клиентские SDK.
- 0.4.0 — наблюдаемость (логирование, трассировка), метрики по контрактам, документация best practices для команд.

## Дальше за базовым списком (смотрим на 2+ шагов вперед)
- Генерация моков по контрактам: фабрики фикстур и mock-server (напр. через OpenAPI/ts-rest) для автотестов и быстрого локального dev без поднятых сервисов.
- Проверка breaking changes: автоматический diff контрактов в CI с блокировкой PR при несовместимых изменениях и автогенерацией release notes.
- SDK/клиенты для других языков: генерация из OpenAPI (Go/Python/Java/Kotlin/Swift) плюс публикация типизированных клиентов в артефакт-хранилища.
- Runtime-валидация продового трафика контрактом: middleware, которое валидирует вход/выход и пишет отклонения в метрики/алерты.
- Consumer-driven contracts: тесты, которые реплеят зафиксированные ожидания фронта/интеграций к текущей версии сервиса, чтобы удерживать обратную совместимость.
- Обогащение контрактов метаданными (auth scopes, rate limits, idempotency keys) и синхронизация этих правил с gateway/policy-движком.
- Каталог и портал контрактов: единый UI с поиском, примерами, changelog и статусами версий (stable/beta/deprecated).
- Ковередж контрактов: метрики “какие операции вызваны в проде”, “какие покрыты тестами” по operationId, чтобы управлять приоритетами.
- Генерация сценарных тестов: цепочки вызовов (user journey) на основе контрактов и примеров, чтобы проверять целостность бизнес-потоков.
- Перформанс/хаос-профили по контрактам: SLO и нагрузочные профили для каждой операции, автоматическое тестирование деградаций.
- Кросс-сервисные схемы: включить события (contract-first для event payloads) и согласовать REST + события в одном пакете контрактов.
- После этих шагов новых универсальных идей не остается — дальше развитие зависит от конкретных бизнес-требований и контекста платформы.
